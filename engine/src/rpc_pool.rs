use solana_client::nonblocking::rpc_client::RpcClient;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse tokio::time::{sleep, Duration};\nuse tracing::{warn, error, info};\n\n/// RPC connection pool with automatic failover\npub struct RpcPool {\n    clients: Vec<Arc<RpcClient>>,\n    current_index: AtomicUsize,\n    retry_delay_ms: u64,\n}\n\nimpl RpcPool {\n    pub fn new(rpc_urls: Vec<String>) -> Self {\n        let clients = rpc_urls\n            .into_iter()\n            .map(|url| Arc::new(RpcClient::new(url)))\n            .collect();\n        \n        Self {\n            clients,\n            current_index: AtomicUsize::new(0),\n            retry_delay_ms: 100,\n        }\n    }\n\n    /// Get the current RPC client\n    pub fn get_client(&self) -> Arc<RpcClient> {\n        let index = self.current_index.load(Ordering::Relaxed);\n        self.clients[index % self.clients.len()].clone()\n    }\n\n    /// Rotate to the next RPC client (failover)\n    pub fn rotate(&self) {\n        let old_index = self.current_index.fetch_add(1, Ordering::Relaxed);\n        let new_index = (old_index + 1) % self.clients.len();\n        warn!(\"ðŸ”„ Rotating RPC client from index {} to {}\", old_index, new_index);\n        crate::telemetry::RPC_ERRORS.inc();\n    }\n\n    /// Execute a request with automatic retry and failover\n    pub async fn execute_with_retry<F, T, Fut>(\n        &self,\n        operation: F,\n        max_retries: usize,\n    ) -> Result<T, String>\n    where\n        F: Fn(Arc<RpcClient>) -> Fut,\n        Fut: std::future::Future<Output = Result<T, solana_client::client_error::ClientError>>,\n    {\n        let mut attempts = 0;\n        let mut last_error = String::new();\n\n        while attempts < max_retries {\n            let client = self.get_client();\n            \n            match operation(client).await {\n                Ok(result) => return Ok(result),\n                Err(e) => {\n                    last_error = e.to_string();\n                    error!(\"RPC request failed (attempt {}/{}): {}\", attempts + 1, max_retries, e);\n                    \n                    // Rotate to next client\n                    self.rotate();\n                    \n                    // Exponential backoff\n                    let delay = self.retry_delay_ms * (1 << attempts.min(5));\n                    sleep(Duration::from_millis(delay)).await;\n                    \n                    attempts += 1;\n                }\n            }\n        }\n\n        Err(format!(\"All RPC attempts failed. Last error: {}\", last_error))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_rpc_pool_rotation() {\n        let pool = RpcPool::new(vec![\n            \"https://api.mainnet-beta.solana.com\".to_string(),\n            \"https://rpc.ankr.com/solana\".to_string(),\n        ]);\n\n        assert_eq!(pool.current_index.load(Ordering::Relaxed), 0);\n        pool.rotate();\n        assert_eq!(pool.current_index.load(Ordering::Relaxed), 1);\n        pool.rotate();\n        assert_eq!(pool.current_index.load(Ordering::Relaxed), 2);\n    }\n}\n
